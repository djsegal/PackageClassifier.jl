MultiJuMP MultiJuMP enables the user to easily run multiobjective optimisation problems and generate Pareto fronts. The code is built as an extension of JuMP . We have implemented three ways to trace out the Pareto front: Normal Boundary Intersection ( solve(m, method = NBI()) ) This method is applicable only for nonlinear optimisation Weighted sums ( solve(m, method = WeightedSum()) ) Constraint methods ( solve(m, method = EpsilonCons()) ) This method only works for biobjective optimisation as of now Disclaimer : MultiJuMP is not developed or maintained by the JuMP developers. Installation In Julia, call Pkg.add("MultiJuMP") to install MultiJuMP. Usage Have a look at the tests and examples/ directory for different use cases, including tri-objective Pareto fronts. MultiJuMP supports linear problems using the linear=true keyword when calling multi_model(linear=true) . Currently, only the EpsilonCons() and WeightedSum() methods are supported for linear problems. using MultiJuMP, JuMP using Clp : ClpSolver const mmodel = multi_model (solver = ClpSolver (), linear = true ) const y = @variable (mmodel, 0 <= y <= 10.0 ) const z = @variable (mmodel, 0 <= z <= 10.0 ) @constraint (mmodel, y + z <= 15.0 ) # objectives const exp_obj1 = @expression (mmodel, - y + 0.05 * z) const exp_obj2 = @expression (mmodel, 0.05 * y - z) const obj1 = SingleObjective (exp_obj1) const obj2 = SingleObjective (exp_obj2) # setting objectives in the data const multim = get_multidata (mmodel) multim . objectives = [obj1, obj2] solve (mmodel, method = WeightedSum ()) # Get the Utopia and Nadir points utopiapoint = getutopia (multim) nadirpoint = getnadir (multim) Plotting with Plots.jl is supported via recipes: using Plots : plot, title! pltlin = plot (multim) title! (pltlin, " Extrema of the Pareto front " ) # Show Utopia and Nadir points # (This is probably a hacky way to do this) scatter! (pltlin, [utopiapoint[ 1 ], nadirpoint[ 1 ]], [utopiapoint[ 2 ], nadirpoint[ 2 ]], label = " Utopia/Nadir " ) As a non-linear usage example, we implement the test from Das and Dennis, 1998: Normal-boundary intersection: A new method for generating the Pareto surface in nonlinear multicriteria optimization problems : using MultiJuMP, JuMP using Ipopt m = multi_model (solver = IpoptSolver ()) @variable (m, x[i = 1 : 5 ]) @NLexpression (m, f1, sum (x[i] ^ 2 for i = 1 : 5 )) @NLexpression (m, f2, 3 x[ 1 ] + 2 x[ 2 ] - x[ 3 ] / 3 + 0.01 * (x[ 4 ] - x[ 5 ]) ^ 3 ) @NLconstraint (m, x[ 1 ] + 2 x[ 2 ] - x[ 3 ] - 0.5 x[ 4 ] + x[ 5 ] == 2 ) @NLconstraint (m, 4 x[ 1 ] - 2 x[ 2 ] + 0.8 x[ 3 ] + 0.6 x[ 4 ] + 0.5 x[ 5 ] ^ 2 == 0 ) @NLconstraint (m, sum (x[i] ^ 2 for i = 1 : 5 ) <= 10 ) iv1 = [ 0.3 , 0.5 , - 0.26 , - 0.13 , 0.28 ] # Initial guess obj1 = SingleObjective (f1, sense = :Min , iv = Dict {Symbol,Any} ( :x => iv1)) obj2 = SingleObjective (f2, sense = :Min ) md = get_multidata (m) md . objectives = [obj1, obj2] md . pointsperdim = 20 solve (m, method = NBI ( false )) # or method = WeightedSum() or method = EpsilonCons() # Get the Utopia and Nadir points utopiapoint = getutopia (md) nadirpoint = getnadir (md) using Plots pltnbi = plot (md)