FixedSizeDictionaries Library which implements a FixedSize variant of Dictionaries. These can be stack allocated and have O(1) indexing performance without boundcheck. It implements most parts of the Base.Dict interface. This package is useful, when you want anonymous composite types. You should be a bit careful with generating a lot of FixedSizeDict's, since it will compile a unique set of functions for every field of a Dict. Usage: # constructors: kvdict = FixedKeyValueDict (( :a => 22 , :b => 3 f0, :c => 3 f0)) FixedKeyValueDict ((( :a , 22 ), ( :b , 3 f0), ( :c , 3 f0))) FixedKeyValueDict ( :a => 22 , :b => 3 f0, :c => 3 f0) FixedKeyValueDict (( :a , :b , :c ), ( 22 , 3 f0, 3 f0)) FixedKeyValueDict ( Dict ( :a => 22 , :b => 3 f0, :c => 3 f0)) @get (kvdict . a) == 22 @get (kvdict . b) == 3 f0 @get (kvdict . c) == 3 f0 keys (kvdict) == (Val{ :a }, Val{ :b }, Val{ :c }) values (kvdict) == ( 22 , 3 f0, 3 f0) val = get (kvdict, Val{ :a }) do " default " end val == 22 val = get (kvdict, Val{ :Y }) do " default " end val == " default " kvdict = FixedKeyDict (( :a => 22 , :b => 3 f0, :c => 3 f0)) kvdict == FixedKeyDict ((( :a , 22 ), ( :b , 3 f0), ( :c , 3 f0))) kvdict == FixedKeyDict ( :a => 22 , :b => 3 f0, :c => 3 f0) kvdict == FixedKeyDict (( :a , :b , :c ), [ 22 , 3 f0, 3 f0]) kvdict == FixedKeyDict ( Dict ( :a => 22 , :b => 3 f0, :c => 3 f0)) # same functions as FixedKeyValueDict plus: @get kvdict . a = 10 values (kvdict) == ( 10 , 3 f0, 3 f0) Automatic generated API docs: FixedSizeDictionaries.AbstractFixedSizeDict{Keys} ¶ Dictionary types which keys are fixed at creation time source: FixedSizeDictionaries/src/core.jl:4 FixedSizeDictionaries.FixedKeyDict{Keys<:Tuple, Values<:AbstractArray{T, 1}} ¶ Dictionary types which keys are fixed at creation time source: FixedSizeDictionaries/src/core.jl:15 FixedSizeDictionaries.FixedKeyValueDict{Keys<:Tuple, Values<:Tuple} ¶ Dictionary types which keys and values are fixed at creation time source: FixedSizeDictionaries/src/core.jl:9 @get(expr) ¶ Allows getfield like access to the keys of a FixedDict source: FixedSizeDictionaries/src/core.jl:145 Internal call(::Type{FixedSizeDictionaries.FixedKeyDict{Keys<:Tuple, Values<:AbstractArray{T, 1}}}, key_values) ¶ Constructor for a list of pairs of key => value. Arbitrary data structures of length 2 can be used source: FixedSizeDictionaries/src/core.jl:63 call(::Type{FixedSizeDictionaries.FixedKeyValueDict{Keys<:Tuple, Values<:Tuple}}, key_values) ¶ Constructor for a list of pairs of key => value. Arbitrary data structures of length 2 can be used source: FixedSizeDictionaries/src/core.jl:41 call{N}(::Type{FixedSizeDictionaries.FixedKeyDict{Keys<:Tuple, Values<:AbstractArray{T, 1}}}, keys::NTuple{N, Symbol}, values::AbstractArray{T, 1}) ¶ Constructor for a list of keys together with a list of values which should have the same length source: FixedSizeDictionaries/src/core.jl:54 call{N}(::Type{FixedSizeDictionaries.FixedKeyValueDict{Keys<:Tuple, Values<:Tuple}}, keys::NTuple{N, Symbol}, values::NTuple{N, Any}) ¶ Constructor for a list of keys together with a list of values which should have the same length source: FixedSizeDictionaries/src/core.jl:31 call{T<:FixedSizeDictionaries.AbstractFixedSizeDict{Keys}}(::Type{T<:FixedSizeDictionaries.AbstractFixedSizeDict{Keys}}, args...) ¶ Generic constructor that dispatches XDict(pair, pair, ...) to XDict((pair, pair)) source: FixedSizeDictionaries/src/core.jl:22 getfield_expr(dict, key) ¶ generates the expression to acces a field of a dict via a Val{Symbol} source: FixedSizeDictionaries/src/core.jl:138