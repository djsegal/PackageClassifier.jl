JuLIP: Julia Library for Interatomic Potentials Build Status Social A package for rapid implementation and testing of new interatomic potentials and molecular simulation algorithms. Requires v0.5 or v0.6 of Julia. Current development is for Julia v0.6.x. Documentation is essentially non-existent but the inline documentations is reasonably complete. The design of JuLIP is heavily inspired by ASE . The main motivation for JuLIP is that, while ASE is pure Python and hence relies on external software to efficiently evaluate interatomic potentials, Julia allows the implementation of fast potentials in pure Julia, often in just a few lines of code. ASE bindings compatible with JuLIP are provided by ASE.jl . Contributions are welcome, especially for producing examples and tutorials. Any questions or suggestions, please ask on . Installation Install JuLIP, from the Julia REPL: Pkg . add ( " JuLIP " ) and run Pkg.test("JuLIP") to make sure the installation succeeded. If a test fails, please open an issue. Most likely you will also want to ASE bindings; please see ASE.jl for more detail. Examples The following are some minimal examples to just get something to run. More intersting examples will hopefully follow soon. Vacancy in a bulk Si cell using JuLIP at = bulk ( :Si , cubic = true ) * 4 deleteat! (at, 1 ) set_calculator! (at, StillingerWeber ()) minimise! (at) # Visualisation is current not working # JuLIP.Visualise.draw(at) # (this will only work in a ipynb) see the BulkSilicon.ipynb notebook under examples for an extended example. Construction of a Buckingham potential using JuLIP r0 = rnn ( :Al ) pot = let A = 4.0 , r0 = r0 @analytic r -> 6.0 * exp ( - A * (r / r0 - 1.0 )) - A * (r0 / r) ^ 6 end pot = pot * SplineCutoff ( 2.1 * r0, 3.5 * r0) # `pot` can now be used as a calculator to do something interesting ... Site Potential with AD using JuLIP # and EAM-like site potential f (R) = sqrt ( 1.0 + sum ( exp ( - norm (r)) for r in R ) ) # wrap it into a site potential type => can be used as AbstractCalculator V = ADPotential (f) # evaluate V and âˆ‡V R0 = [ @SVector rand ( 3 ) for n = 1 : nneigs ] @show V (R0) @show ( @D V (R0))