PersistentHomologyTransfer.jl Persistent Homology Transform is produced and maintained by Yossi Bokor and Katharine Turner yossi.bokor@anu.edu.au and katharine.turner@anu.edu.au This package provides an implementation of the Persistent Homology Transform, as defined in Persistent Homology Transform for Modeling Shapes and Surfaces . It also does Rank Functions of Persistence Diagrams, and implements Prinipal Component Analysis of Rank functions . Installation Currently, the best way to install PersistentHomologyTransfer is to run the following in Julia : using Pkg Pkg . add (PersistentHomologyTransfer) Functionality PersistentHomologyTransfer computes the Persistent Homology Transform of simple, closed curves in $\mathbb{R}^2$. Rank functions of persistence diagrams. Principal Component Analysis of Rank Functions. Persistent Homology Transform Given an $m \times 2$ matrix of ordered points sampled from a simple, closed curve $C \subset \mathbb{R}^2$ (in either a clockwise or anti-clockwise direction), calculate the Persistent Homology Transform for a set of directions. You can either specify the directions explicity as a $n \times 2$ array ( directions::Array{Float64}(n,2) ), or specify an integer ( directions::Int64 ) and then the directions used will be generated by angles = [n * pi / (directions / 2 ) for n in 1 : directions] directions = [[ cos (x), sin (x)] for x in angles] To perform the Persistent Homology Transfer for the directions, run PHT (points, directions) This outputs an array of Eirene Persistence Diagrams, one for each direction. Rank Functions Given an Eirene Persistence Diagram $D$, PersistentHomologyTransfer can calculate the Rank Function $r_D$ either exactly, or given a grid of points, calculate a discretised version. Recall that $D$ is an $n \times 2$ array of points, and hence the function Total_Rank_Exact accepts an $n \times 2$ array of points, and returns a list of points critical points of the Rank function and the value at each of these points. Running rk = Total_Rank_Exact (barcode) we obtain the critical points via rk[ 1 ] which returns an array of points in $\mathbb{R}^2$, and the values through rk[ 2 ] wich returns an array of integers. To obtain a discrete approximation of a Rank Function over a persistence diagram $D$, use Total_Rank_Grid , which acceps as input an Eirene Persistence Diagram $D$, an increasing StepRange for $x$-coordinates x_g , and a decreasing StepRange for $y$-coordinates y_g . The StepRanges are obtained by running x_g = lb : delta : ub x_g = ub : - delta : lb with lb being the lower bound so that $(lb, lb)$ is the lower left corner of the grid, and ub being the upper bound so that $(ub,ub)$ is the top right corner of the grid, and $delta$ is the step size. Finally, the rank is obtained by rk = Total_Rank_Grid (D, x_g, y_g) which returns an array or values. PCA of Rank Functions Given a set of rank functions, we can perform principal component analysis on them. The easiest way to do this is to use the wrapper function PCA which has inputs an array of rank functions evaluated at the same points (best to use Total_Rank_Grid to obtain them), an dimension $d$ and an array of weights weights , where the weights correspond to the grid points used in Total_Rank_Grid . To perform Principal Component Analysis and obtain the scores run scores = PCA (ranks, d, weights) which returns the scores in $d$-dimensions. Examples Persistent Homology Transfer We will go through an example using a random shape and 20 directions. You can download the CSV file from here To begin, load the CSV file into an array in Julia Boundary = CSV . read ( " <path/to/file> " ) Persistence_Diagrams = PHT (Boundary, 20 ) You can then access the persistence diagram corresponding to the $i^{th}$ direction as Persistence_Diagrams[i]