Reactive extensions library for Julia Rocket.jl is a Julia package for reactive programming using Observables, to make it easier to work with asynchronous data. In order to achieve best performance and convenient API Rocket.jl combines Observer pattern , Actor model and Functional programming . Inspired by RxJS and ReactiveX communities. Rocket.jl has been designed with a focus on performance and modularity. The essential concepts in Rocket.jl are: Observable : represents a collection of future messages (data or/and events). Actor : is an object that knows how to react on incoming messages delivered by the Observable . Subscription : represents a teardown logic which might be useful for cancelling the execution of an Observable . Operators : are objects that enable a functional programming style to dealing with collections with operations like map , filter , reduce , etc. Subject : the way of multicasting a message to multiple Observers. Quick start For a quick start and basic introduction take a look at the demo folder and Quick Start notebook . Documentation A full documentation is available at BIASlab website . It is also possible to build a documentation locally. Just use $ julia make.jl in the docs/ directory to build local version of the documentation. First example Normally you use an arrays for processing some data. for value in array_of_values doSomethingWithMyData (value) end In Rocket.jl you will use an observable. subscription = subscribe! (source_of_values, lambda ( on_next = (data) -> doSomethingWithMyData (data), on_error = (error) -> doSomethingWithAnError (error), on_complete = () -> println ( " Completed! " ) )) At some point of time you may decide to stop listening for new messages. unsubscribe! (subscription) Actors To process messages from an observable you have to define an Actor that know how to react on incoming messages. struct MyActor <: Rocket.Actor{Int} end Rocket . on_next! (actor :: MyActor , data :: Int ) = doSomethingWithMyData (data) Rocket . on_error! (actor :: MyActor , error) = doSomethingWithAnError (error) Rocket . on_complete! (actor :: MyActor ) = println ( " Completed! " ) Actor can also have its own local state struct StoreActor{D} <: Rocket.Actor{} values :: Vector{D} StoreActor {D} () where D = new ( Vector {D} ()) end Rocket . on_next! (actor :: StoreActor{D} , data :: D ) where D = push! (actor . values, data) Rocket . on_error! (actor :: StoreActor , error) = doSomethingWithAnError (error) Rocket . on_complete! (actor :: StoreActor ) = println ( " Completed: $(actor . values) " ) For debugging purposes you can use a general LambdaActor actor or just pass a function object as an actor in subscribe! function. Operators What makes Rocket.jl powerful is its ability to help you process, transform and modify the messages flow through your observables using Operators . List of all available operators can be found in the documentation ( link ). squared_int_values = source_of_int_values |> map (Int, (d) -> d ^ 2 ) subscribe! (squared_int_values, lambda ( on_next = (data) -> println (data) )) Rocket.jl is fast Rocket.jl has been designed with a focus on efficiency, scalability and maximum performance. Below is a benchmark comparison between Rocket.jl, Signals.jl and Reactive.jl . Code is available in demos folder : TODO This package in under development and some features of reactive framework may be missing List of not implemented features High-order observables and operators ( mergeMap , concatMap , etc..) Join operators: combineLatest , concatAll , etc.. More transformation, filtering, utility operators Possible bugs (welcome to open a PR)