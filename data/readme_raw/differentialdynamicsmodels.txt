DifferentialDynamicsModels.jl Originally written to support MotionPlanning.jl , this package contains a core set of abstractions for working with dynamical systems of the form , where and represent the state and control input of the system, respectively. This package is not intended to be a substitute for more comprehensive/domain-specific packages (e.g., DynamicalSystems.jl , RigidBodyDynamics.jl , or DifferentialEquations.jl ); instead it aims to be as lightweight as possible while offering an extensible framework for operations on state/control trajectories relevant to robot trajectory planning. DifferentialDynamicsModels.jl exports the following types: DifferentialDynamics — abstract type representing the in . Instances of concrete subtypes should be callable , i.e., implement (::MyDynamics)(x, u) . Examples include: SingleIntegratorDynamics{N} defined in this package. Implements the dynamics . The type parameter N denotes the state and control dimension. LinearDynamics{Dx,Du} defined in LinearDynamicsModels.jl . Implements the dynamics . The type parameters Dx and Du denote the state and control dimension respectively. SimpleCarDynamics{Dv,Dκ} defined in SimpleCarModels.jl . Implements unicycle dynamics extended by Dv and Dκ integrators in the speed and curvature controls respectively. BicycleModel defined in Pigeon.jl . Implements a single-track (i.e., "bicycle") vehicle model for use in QP-based model predictive control. ControlInterval — abstract type representing a control function defined over a time interval. Concrete subtypes include: StepControl (a.k.a. ZeroOrderHoldControl ) — constant control input over a time interval. RampControl (a.k.a. FirstOrderHoldControl ) — linear interpolation between two control inputs over a time interval. BVPControl — a wrapper around state/control trajectory functions produced, e.g., by an external boundary value problem solver. CostFunctional - abstract type representing an objective for optimal control. Concrete subtypes include: Time — trajectory duration . TimePlusQuadraticControl — mixed time/control effort penalty . SteeringBVP{D<:DifferentialDynamics,C<:CostFunctional,SC<:SteeringConstraints,SD<:SteeringCache} — concrete type that serves as a container that both defines a two-point boundary value problem (i.e., "steering problem" connecting two states in robot motion planning parlance) and provides the means to solve it. Instances should be callable, i.e., users should define (::SteeringBVP{MyDynamics,MyCostFunctional,MySteeringConstraints,MySteeringCache}) returning a named tuple (cost=..., controls=...) , leveraging Julia's multiple-dispatch on the SteeringBVP type parameters to select the right implementation. Examples include: GeometricSteering — SingleIntegratorDynamics with a Time optimization objective and BoundedControlNorm control constraint (equivalent to optimizing Euclidean arc length). LinearQuadraticSteering — LinearDynamics with a TimePlusQuadraticControl optimization objective and no control constraints. DubinsSteering and ReedsSheppSteering — minimum arc length Dubins and Reeds-Shepp steering for a simple car with minimum turning radius. DifferentialDynamicsModels.jl defines the following functions that can and should be extended by dependent packages if applicable: state_dim(::DifferentialDynamics) — dimension of the state . control_dim(::DifferentialDynamics) — dimension of the control input . duration(controls) — length of the time interval over which controls is defined; controls may be a single ControlInterval or an iterable container (e.g., a Vector ) of ControlInterval s. propagate(f::DifferentialDynamics, x::State, controls, ts) — propagates the dynamics ODE f starting from x to return a state or sequence of states at times ts . controls may be a single ControlInterval or an iterable of ControlInterval s. ts may be a single Number , an iterable of Number s, or not be included as an argument at all, in which case it defaults to duration(controls) . waypoints(f::DifferentialDynamics, x::State, controls, dt_or_N) — similar to propagate but returns equally spaced states (in time) along the controlled trajectory. dt_or_N may be an AbstractFloat or an Int , corresponding to a desired spacing dt or a desired total number of waypoints N . instantaneous_control(controls, ts) — similar to propagate but returns the control input instead of the state at ts . Performance-oriented users may note that the last three functions allocate and return Vector s in the case that ts is an iterable; this package also defines the Propagate and InstantaneousControl iterators constructed in the same ways that their function counterparts are called ( waypoints_itr also exists, and returns a Propagate iterator).