OpenCL.jl OpenCL bindings for Julia Build status : Code coverage : Julia interface for the OpenCL parallel computation API This package aims to be a complete solution for OpenCL programming in Julia, similar in scope to PyOpenCL for Python. It provides a high level api for OpenCL to make programing GPU's and multicore CPU's much less onerous. OpenCL.jl provides access to OpenCL API versions 1.0, 1.1, 1.2 and 2.0. This package is based off the work of others: PyOpenCL by Andreas Klockner oclpb by Sean Ross Boost.Compute by Kyle Lutz rust-opencl OpenCL.jl has had contributions from many developers . Currently supported Julia versions Julia v"0.4.x" is supported on the release-0.4 branch and the OpenCL.jl versions v"0.4.x" . Only bug-fixes will be applied. Julia v"0.5.x" is supported on the master branch and the OpenCL.jl versions v"0.5.x" . Julia v"0.6.x" is experimentally supported on the master branch and the OpenCL.jl versions v"0.5.x" . Discontinued support Julia v"0.3.x" was supported on OpenCL.jl versions v"0.3.x" . It should still be installable and work. Setup Install an OpenCL driver. If you use OSX, OpenCL is already available Checkout the packages from the Julia repl Pkg . add ( " OpenCL " ) OpenCL will be installed in your .julia directory cd into your .julia directory to run the tests and try out the examples To update to the latest development version, from the Julia repl: Pkg . update () IJulia Notebooks OpenCL Fractals GPU Buffer Transpose Low Level API Quick Example using OpenCL const sum_kernel = " __kernel void sum(__global const float *a, __global const float *b, __global float *c) { int gid = get_global_id(0); c[gid] = a[gid] + b[gid]; } " a = rand (Float32, 50_000 ) b = rand (Float32, 50_000 ) device, ctx, queue = cl . create_compute_context () a_buff = cl . Buffer (Float32, ctx, ( :r , :copy ), hostbuf = a) b_buff = cl . Buffer (Float32, ctx, ( :r , :copy ), hostbuf = b) c_buff = cl . Buffer (Float32, ctx, :w , length (a)) p = cl . Program (ctx, source = sum_kernel) |> cl . build! k = cl . Kernel (p, " sum " ) queue (k, size (a), nothing , a_buff, b_buff, c_buff) r = cl . read (queue, c_buff) if isapprox ( norm (r - (a + b)), zero (Float32)) info ( " Success! " ) else error ( " Norm should be 0.0f " ) end