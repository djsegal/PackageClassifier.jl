Polynomials Basic arithmetic, integration, differentiation, evaluation, and root finding over dense univariate polynomials. Master branch: Documentation: Poly(a::Vector) where {T<:Number} Construct a polynomial from its coefficients, lowest order first. julia > Poly ([ 1 , 0 , 3 , 4 ]) Poly ( 1 + 3 x ^ 2 + 4 x ^ 3 ) An optional variable parameter can be added. julia > Poly ([ 1 , 2 , 3 ], :s ) Poly ( 1 + 2 s + 3 s ^ 2 ) poly(r::AbstractVector) Construct a polynomial from its roots. This is in contrast to the Poly constructor, which constructs a polynomial from its coefficients. // Represents (x - 1 ) * (x - 2 ) * (x - 3 ) julia > poly ([ 1 , 2 , 3 ]) Poly ( - 6 + 11 x - 6 x ^ 2 + x ^ 3 ) +, -, *, /, div, == The usual arithmetic operators are overloaded to work on polynomials, and combinations of polynomials and scalars. julia > p = Poly ([ 1 , 2 ]) Poly ( 1 + 2 x) julia > q = Poly ([ 1 , 0 , - 1 ]) Poly ( 1 - x ^ 2 ) julia > 2 p Poly ( 2 + 4 x) julia > 2 + p Poly ( 3 + 2 x) julia > p - q Poly ( 2 x + x ^ 2 ) julia > p * q Poly ( 1 + 2 x - x ^ 2 - 2 x ^ 3 ) julia > q / 2 Poly ( 0.5 - 0.5 x ^ 2 ) julia > q รท p # `div`, also `rem` and `divrem` Poly ( 0.25 - 0.5 x) Note that operations involving polynomials with different variables will error. julia > p = Poly ([ 1 , 2 , 3 ], :x ) julia > q = Poly ([ 1 , 2 , 3 ], :s ) julia > p + q ERROR : Polynomials must have same variable. To get the degree of the polynomial use the degree method julia> degree(p) 2 julia> degree(p^2) 4 julia> degree(p-p) -1 polyval(p::Poly, x::Number) Evaluate the polynomial p at x . julia > p = Poly ([ 1 , 0 , - 1 ]) julia > polyval (p, 0.1 ) 0.99 A call method is also available: julia > p ( 0.1 ) 0.99 polyint(p::Poly, k::Number=0) Integrate the polynomial p term by term, optionally adding constant term k . The order of the resulting polynomial is one higher than the order of p . julia > polyint ( Poly ([ 1 , 0 , - 1 ])) Poly (x - 0.3333333333333333 x ^ 3 ) julia > polyint ( Poly ([ 1 , 0 , - 1 ]), 2 ) Poly ( 2.0 + x - 0.3333333333333333 x ^ 3 ) polyder(p::Poly) Differentiate the polynomial p term by term. The order of the resulting polynomial is one lower than the order of p . julia > polyder ( Poly ([ 1 , 3 , - 1 ])) Poly ( 3 - 2 x) roots(p::Poly) Return the roots (zeros) of p , with multiplicity. The number of roots returned is equal to the order of p . By design, this is not type-stable, the returned roots may be real or complex. julia > roots ( Poly ([ 1 , 0 , - 1 ])) 2 - element Array{Float64, 1 } : - 1.0 1.0 julia > roots ( Poly ([ 1 , 0 , 1 ])) 2 - element Array{Complex{Float64}, 1 } : 0.0 + 1.0im 0.0 - 1.0im julia > roots ( Poly ([ 0 , 0 , 1 ])) 2 - element Array{Float64, 1 } : 0.0 0.0 polyfit(x, y, n=length(x)-1) polyfit : fits a polynomial (of order n ) to x and y using a least-squares approximation. julia > xs = 1 : 4 ; ys = exp .(xs); polyfit (xs, ys) Poly ( - 7.717211620141281 + 17.9146616149694 x - 9.77757245502143 x ^ 2 + 2.298404288652356 x ^ 3 ) Visual example: Other methods Polynomial objects also have other methods: 0-based indexing is used to extract the coefficients of $a_0 + a_1 x + a_2 x^2 + ...$, coefficients may be changed using indexing notation. coeffs : returns the entire coefficient vector degree : returns the polynomial degree, length is 1 plus the degree variable : returns the polynomial symbol as a degree 1 polynomial norm : find the p -norm of a polynomial conj : finds the conjugate of a polynomial over a complex fiel truncate : set to 0 all small terms in a polynomial; chop chops off any small leading values that may arise due to floating point operations. gcd : greatest common divisor of two polynomials. Pade : Return the Pade approximant of order m/n for a polynomial as a Pade object. See also MultiPoly.jl for sparse multivariate polynomials MultivariatePolynomials.jl for multivariate polynomials and moments of commutative or non-commutative variables Nemo.jl for generic polynomial rings, matrix spaces, fraction fields, residue rings, power series PolynomialRoots.jl for a fast complex polynomial root finder