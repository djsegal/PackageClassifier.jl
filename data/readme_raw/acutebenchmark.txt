AcuteBenchmark AcuteBenchmark allows you to benchmark functions that get Arrays as their input. It is used inside IntelVectorMath for benchmarking its functions. A fully working example available here: https://github.com/JuliaMath/VML.jl/blob/AcuteBenchmark/benchmark/benchmark.jl Creates random inputs for a function based on limits, types, and dims specified. config = Funb ( fun = sin, limits = [( - 1 , 1 )], types = [Float32, Float64], dims = [ 100 ], ) or just in a compact form: config = Funb ( sin, [( - 1 , 1 )], [Float32, Float64], [ 10 ]) use benchmark! to run the benchmark: using AcuteBenchmark configs = FunbArray ([ Funb ( sin, [( - 1 , 1 )],[Float32, Float64], [ 10 ] ); Funb ( atan, [( - 1 , 1 ), ( - 1 , 1 )],[Float32, Float64],[ 10 , 10 ] ); Funb ( * , [( - 1 , 1 ), ( - 1 , 1 ), ( - 1 , 1 )], [Float32, Float64], [( 10 , 10 ), ( 10 , 10 )] ); ]) benchmark! (configs) Plot the benchmark result using: bar (configs) To have a same color for the same types use: bar (configs, uniqueType = true , dimAnnotation = true ) To plot the relative speed, pass a pair of configs: bar (configsRealBase => configsRealIVM, uniqueType = true , dimAnnotation = false , uniqueDim = true , " Base " => " IntelVectorMath " ) To plot how the function acts over different dimension sets: configs2 = Funb ( sin, [( - 1 , 1 )],[Float32, Float64], [ 10 20 30 40 ] ); benchmark! (configs2) dimplot (configs2) To compare different sets pass an array of configs: dimplot ([configsRealBase,configsRealIVM],[ " Base " , " IntelVectorMath " ])