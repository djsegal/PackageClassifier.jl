NameResolution Cross-language name resolutions. To solve the scope of following codes, function f (x) # enter f, enter x, x is local y = 1 + x # enter y, require x g -> begin y = 2 # enter g, g is local y + g # require y, require g end end we can use NameResolution.jl to achieve this, check test/runtests.jl for more details. ana = top_analyzer () enter! (ana, :f ) is_local! (ana, :x ) enter! (ana, :x ) enter! (ana, :y ) require! (ana, :x ) lambda = child_analyzer! (ana) is_local! (lambda, :g ) enter! (lambda, :g ) enter! (lambda, :y ) require! (lambda, :y ) require! (lambda, :g ) run_analyzer (ana) println ( " f " , ana . solved) println ( " lambda " , lambda . solved) outputs: julia > println ( " f " , ana . solved . x) f Scope ( bounds = { f => LocalVar (f, is_mutable = false , is_shared = false ), y => LocalVar (y, is_mutable = true , is_shared = true ), x => LocalVar (x, is_mutable = false , is_shared = false ), }, freevars = {}, parent = nothing , ) julia > println ( " lambda " , lambda . solved . x) lambda Scope ( bounds = { g => LocalVar (g, is_mutable = false , is_shared = false ), }, freevars = { y => LocalVar (y, is_mutable = true , is_shared = true ), }, parent = Scope ( bounds = { f => LocalVar (f, is_mutable = false , is_shared = false ), y => LocalVar (y, is_mutable = true , is_shared = true ), x => LocalVar (x, is_mutable = false , is_shared = false ), }, freevars = {}, parent = nothing , ), ) 