CurrenciesBase.jl Purpose This package provides the core functionality for Currencies.jl . Data Source The currency-related information for this package comes from this Wikipedia page , the official ISO standard, and other Wikipedia pages. It is compiled manually and may be in error; please do submit a pull request to correct any errors. Usage This README.md file provides a basic guide to getting started. It is not a replacement for the documentation . Please file any corrections or missing parts of the documentation as issues, or even better, send in a pull request. The Currencies module exports the Monetary type. To access currencies, use the @usingcurrencies macro. Basic operation is as follows: @usingcurrencies USD 1 USD + 2 USD # 3.00 USD 3 * 1.5 USD # 4.50 USD Mixed arithmetic is not supported: @usingcurrencies USD, CAD 10 USD + 3 CAD # ArgumentError Monetary amounts can be compared: @usingcurrencies USD, EUR 1 USD < 2 USD # true sort ([ 2 EUR, 1 EUR]) # [1EUR, 2EUR] Using Monetary in Practice Monetary types behave a lot like integer types, and they can be used like them for a lot of practical situations. For example, here is a (quite fast) function to give optimal change using the common European system of having coins and bills worth 0.01€, 0.02€, 0.05€, 0.10€, 0.20€, 0.50€, 1.00€, and so forth until 500.00€ (this algorithm doesn't necessarily work for all combinations of coin values). @usingcurrencies EUR COINS = [ 500 EUR, 200 EUR, 100 EUR, 50 EUR, 20 EUR, 10 EUR, 5 EUR, 2 EUR, 1 EUR, 0.5 EUR, 0.2 EUR, 0.1 EUR, 0.05 EUR, 0.02 EUR, 0.01 EUR] function change (amount :: Monetary{:EUR,Int} ) coins = Dict {Monetary{:EUR,Int}, Int} () for denomination in COINS coins[denomination], amount = divrem (amount, denomination) end coins end sum ([k * v for (k, v) in change ( 167.25 EUR)]) # 167.25EUR