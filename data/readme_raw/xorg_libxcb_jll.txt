Xorg_libxcb_jll.jl This is an autogenerated package constructed using BinaryBuilder.jl . Products The code bindings within this package are autogenerated from the following Products defined within the build_tarballs.jl file that generated this package: products = [ LibraryProduct ([ " libxcb-composite " ], :libxcb_composite ), LibraryProduct ([ " libxcb-xkb " ], :libxcb_xkb ), LibraryProduct ([ " libxcb-screensaver " ], :libxcb_screensaver ), LibraryProduct ([ " libxcb " ], :libxcb ), LibraryProduct ([ " libxcb-record " ], :libxcb_record ), LibraryProduct ([ " libxcb-xfixes " ], :libxcb_xfixes ), LibraryProduct ([ " libxcb-shm " ], :libxcb_shm ), LibraryProduct ([ " libxcb-dri2 " ], :libxcb_dri2 ), LibraryProduct ([ " libxcb-damage " ], :libxcb_damage ), LibraryProduct ([ " libxcb-dpms " ], :libxcb_dpms ), LibraryProduct ([ " libxcb-xinput " ], :libxcb_xinput ), LibraryProduct ([ " libxcb-sync " ], :libxcb_sync ), LibraryProduct ([ " libxcb-xinerama " ], :libxcb_xinerama ), LibraryProduct ([ " libxcb-xtest " ], :libxcb_xtest ), LibraryProduct ([ " libxcb-xvmc " ], :libxcb_xvmc ), LibraryProduct ([ " libxcb-present " ], :libxcb_present ), LibraryProduct ([ " libxcb-glx " ], :libxcb_glx ), LibraryProduct ([ " libxcb-xv " ], :libxcb_xv ), LibraryProduct ([ " libxcb-res " ], :libxcb_res ), LibraryProduct ([ " libxcb-randr " ], :libxcb_randr ), LibraryProduct ([ " libxcb-xf86dri " ], :libxcb_xf86dri ), LibraryProduct ([ " libxcb-shape " ], :libxcb_shape ), LibraryProduct ([ " libxcb-render " ], :libxcb_render ), LibraryProduct ([ " libxcb-dri3 " ], :libxcb_dri3 ) ] Usage example For example purposes, we will assume that the following products were defined in the imaginary package Example_jll : products = [ FileProduct ( " src/data.txt " , :data_txt ), LibraryProduct ( " libdataproc " , :libdataproc ), ExecutableProduct ( " mungify " , :mungify_exe ) ] With such products defined, Example_jll would contain data_txt , libdataproc and mungify_exe symbols exported. For FileProduct variables, the exported value is a string pointing to the location of the file on-disk. For LibraryProduct variables, it is a string corresponding to the SONAME of the desired library (it will have already been dlopen() 'ed, so typical ccall() usage applies), and for ExecutableProduct variables, the exported value is a function that can be called to set appropriate environment variables. Example: using Example_jll # For file products, you can access its file location directly: data_lines = open (data_txt, " r " ) do io readlines (io) end # For library products, you can use the exported variable name in `ccall()` invocations directly num_chars = ccall ((libdataproc, :count_characters ), Cint, (Cstring, Cint), data_lines[ 1 ], length (data_lines[ 1 ])) # For executable products, you can use the exported variable name as a function that you can call mungify_exe () do mungify_exe_path run ( ` $mungify_exe_path $num_chars ` ) end